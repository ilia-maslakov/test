![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.001.jpeg)

**I. Design Patterns**

- **Введение**

Паттерны проектирования являются фундаментальной частью разработки программного обеспечения (далее - ПО), поскольку они обеспечивают типичные решения часто повторяющихся проблем при проектировании ПО. Вместо того чтобы предоставлять конкретные части ПО, паттерны проектирования — это всего лишь концепции, которые можно использовать для оптимального решения повторяющихся проблем.

За последние несколько лет экосистема веб-разработки сильно изменилась. В то время как некоторые известные паттерны проектирования, возможно, уже не так ценны, как раньше, другие эволюционировали, чтобы решать современные проблемы с помощью новейших технологий.

JavaScript-библиотека React от Facebook за последние 5 лет приобрела огромную популярность и в настоящее время является [наиболее загружаемым фреймворком на NPM](https://www.npmtrends.com/@angular/core-vs-angular-vs-react-vs-vue-vs-ember-source-vs-svelte) по сравнению с конкурирующими JavaScript-библиотеками, такими как Angular, Vue, Ember и Svelte. Благодаря популярности React, паттерны проектирования были изменены, оптимизированы и созданы новые, чтобы обеспечить ценность в текущей современной экосистеме веб-разработки. В последней версии React появилась новая функция под названием Hooks, которая играет очень важную роль в дизайне вашего приложения и может заменить многие традиционные паттерны проектирования. Современная веб-разработка включает в себя множество различных паттернов. В этом проекте рассматриваются реализация, преимущества и подводные камни распространенных паттернов проектирования с использованием ES2015+, специфические для React паттерны проектирования и их возможная модификация и реализация с использованием React Hooks, а также многие другие паттерны и оптимизации, которые могут помочь улучшить ваше современное веб-приложение!

- **Паттерн Singleton («Синглтон»)**

*Совместное использование одного глобального экземпляра во всем нашем приложении*

Singleton — это класс, экземпляр, которого может быть создан один раз, а доступ к нему может быть глобальным. Этот единственный экземпляр может быть общим для всего нашего приложения, что делает Singleton отличным средством управления глобальным состоянием в приложении.

Сначала давайте посмотрим, как может выглядеть Singleton, на примере класса ES2015. Для этого примера мы создадим класс Counter, который имеет:

- метод getInstance, который возвращает значение экземпляра;
- метод getCount, который возвращает текущее значение переменной счетчика;
- метод increment, который увеличивает значение счетчика на единицу;
- метод decrement, который уменьшает значение счетчика на единицу.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.002.jpeg)

Однако этот класс не соответствует критериям Singleton! Singleton может быть **создан только один раз.** В настоящее время мы можем создать несколько экземпляров класса Counter.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.003.jpeg)Вызвав новый метод дважды, мы просто установили counter1 и counter2, равными разным экземплярам. Значения, возвращенные методом getInstance для counter1 и counter2, фактически вернули ссылки на разные экземпляры: они не являются строго равными!

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.004.jpeg)

Давайте убедимся, что может быть создан только один экземпляр класса Counter. Один из способов убедиться в том, что может быть создан только один экземпляр,

- это создать переменную instance. В конструкторе счетчика мы можем установить instance равной ссылке на экземпляр, когда создается новый экземпляр. Мы можем предотвратить создание новых экземпляров, проверив, не имеет ли переменная instance уже значения. Если это так, то экземпляр уже существует.

Этого не должно произойти: у пользователя должна возникнуть ошибка.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.005.jpeg)

Отлично! Мы больше не можем создавать несколько экземпляров.

Давайте экспортируем экземпляр Counter из файла counter.js. Но прежде чем это сделать, мы должны **заморозить** экземпляр. Метод Object.freeze гарантирует, что потребляющий код не сможет изменить Singleton. Свойства замороженного экземпляра не могут быть добавлены или изменены, что снижает риск случайной перезаписи значений Singleton.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.006.jpeg)

Давайте рассмотрим приложение, реализующее пример со счетчиком. У нас есть следующие файлы:

- counter.js: содержит класс Counter и экспортирует **экземпляр Counter** в качестве экспорта по умолчанию;
- index.js: загружает модули redButton.js и blueButton.js;
- redButton.js: импортирует Counter, добавляет метод инкремента Counter в качестве слушателя событий на красную кнопку и регистрирует текущее значение счетчика, вызывая метод getCount;
- blueButton.js: импортирует Counter, добавляет метод инкремента Counter в качестве слушателя событий для синей кнопки и регистрирует текущее значение счетчика, вызывая метод getCount.

И blueButton.js, и redButton.js импортируют **один и тот же экземпляр** из counter.js. Этот экземпляр импортируется как **Counter** в обоих файлах.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.007.jpeg)

Когда мы вызываем метод increment в файле redButton.js или blueButton.js, значение свойства counter экземпляра Counter обновляется в обоих файлах. Неважно, нажимаем ли мы на красную или синюю кнопку: одно и то же значение является общим для всех экземпляров. Вот почему счетчик продолжает увеличиваться на единицу, даже если мы вызываем метод в разных файлах.

**(Не)преимущества**

Ограничение инстанцирования только одним экземпляром потенциально может сэкономить много места в памяти. Вместо того чтобы каждый раз выделять память для нового экземпляра, нам нужно выделить память только для одного экземпляра, на который будут ссылаться во всем приложении. Однако Singleton фактически считаются **антипаттерном**, и их можно (или... нужно) избегать в JavaScript.

Во многих языках программирования, например, в Java или C++, невозможно напрямую создавать объекты так, как мы можем это делать в JavaScript. В этих объектно-ориентированных языках программирования нам нужно создать класс, который создает объект. Этот созданный объект имеет значение экземпляра класса, точно так же, как значение экземпляра в примере JavaScript.

Однако реализация класса, показанная в примерах выше, на самом деле излишняя. Поскольку мы можем напрямую создавать объекты в JavaScript, мы можем просто использовать обычный объект для достижения точно такого же результата. Давайте рассмотрим некоторые недостатки использования Singleton!

**Использование обычного объекта**

Давайте воспользуемся тем же примером, который мы рассматривали ранее. Однако на этот раз счетчик — это просто объект, содержащий:

- свойство count;
- метод increment, который увеличивает значение count на единицу;
- метод decrement, который уменьшает значение count на единицу.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.008.png)

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/competent-moon-rvzrr>*

Поскольку объекты передаются по ссылке, и redButton.js, и blueButton.js импортируют ссылку на один и тот же объект счетчика. Изменение значения count в любом из этих файлов приведет к изменению значения счетчика, которое видно в обоих файлах.

**Тестирование**

Тестирование кода, который полагается на Singleton, может оказаться сложным. Поскольку мы не можем каждый раз создавать новые экземпляры, все тесты зависят от модификации глобального экземпляра предыдущего теста. В этом случае порядок тестов имеет значение, и одно небольшое изменение может привести к неудаче всего набора тестов. После тестирования нам необходимо перезагрузить весь экземпляр, чтобы сбросить изменения, внесенные тестами.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.009.jpeg)

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/sweet-cache-n55vi>*

**Скрытие зависимостей**

При импорте другого модуля, в данном случае superCounter.js, может быть неочевидно, что модуль импортирует Singleton. В других файлах, таких как index.js в данном случае, мы можем импортировать этот модуль и вызывать его методы. Таким образом, мы случайно изменяем значения в Singleton. Это может привести к неожиданному поведению, так как несколько экземпляров Singleton могут быть общими для всего приложения, и все они также будут изменены.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.010.png)

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/sweet-cache-n55vi>*

**Глобальное поведение**

Экземпляр Singleton должен быть доступен для ссылок во всем приложении. Глобальные переменные по сути демонстрируют такое же поведение: поскольку глобальные переменные доступны в глобальной области видимости, мы можем обращаться к ним во всем приложении.

Наличие глобальных переменных обычно считается плохим архитектурным решением. Загрязнение глобальной области видимости может закончиться случайной перезаписью значения глобальной переменной, что может привести к множеству неожиданных действий.

В ES2015 создание глобальных переменных — довольно редкое явление. Новые ключевые слова let и const предотвращают случайное загрязнение глобальной области видимости, поскольку переменные, объявленные с помощью этих двух ключевых слов, имеют блочную область видимости. Новая система модулей в JavaScript упрощает создание глобально доступных значений, не загрязняя глобальную область видимости, благодаря возможности экспортировать значения из модуля и импортировать их в другие файлы.

Однако, обычно Singleton используется для того, чтобы иметь некое **глобальное состояние** во всем приложении. Если несколько частей вашей кодовой базы полагаются на один и тот же **изменяемый объект**, это может привести к неожиданному поведению.

Обычно определенные части кодовой базы изменяют значения в глобальном состоянии, в то время как другие потребляют эти данные. Здесь важен порядок выполнения: мы не хотим случайно сначала потреблять данные, когда их еще нет (пока)! Понимание потока данных при использовании глобального состояния может стать очень сложным по мере роста вашего приложения, когда десятки компонентов зависят друг от друга.

**Управление состоянием в React**

В React мы часто полагаемся на глобальное состояние через инструменты управления состоянием, такие как **Redux** или **React Context**, вместо использования Singleton. Хотя поведение их глобального состояния может показаться похожим на поведение Singleton, эти инструменты предоставляют состояние **только для чтения**, а не изменяемое состояние Singleton. При использовании Redux только редьюсеры могут обновлять состояние, после того как компонент отправил действие (action) через dispatch.

Хотя, недостатки глобального состояния не исчезают волшебным образом при использовании этих инструментов, по крайней мере, мы можем быть уверены, что глобальное состояние изменяется так, как мы задумали, поскольку компоненты не могут обновлять состояние напрямую.

- **Паттерн Proxy**

*Перехват и управление взаимодействием с целевыми объектами*

С помощью прокси-объекта мы получаем больше контроля над взаимодействием с определенными объектами. Прокси-объект может переопределять поведение всякий раз, когда мы взаимодействуем с объектом, например, когда мы получаем значение или устанавливаем значение.

Вообще говоря, proxy означает представителя кого-то другого (например, человека). Вместо того чтобы говорить с этим человеком напрямую, вы будете говорить с прокси-персоной, которая будет представлять человека, с которым вы пытались связаться. То же самое происходит и в JavaScript: вместо того чтобы взаимодействовать с целевым объектом напрямую, мы будем взаимодействовать с прокси-объектом.

Давайте создадим объект person, который представляет John Doe *(прим. перев. - неизвестный).*

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.011.png)

Вместо того чтобы взаимодействовать с этим объектом напрямую, мы хотим взаимодействовать с прокси-объектом. В JavaScript мы можем легко создать новый прокси-объект, создав новый экземпляр Proxy.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.012.png)

Вторым аргументом Proxy является объект, представляющий обработчик. В объекте обработчика мы можем определить конкретное поведение в зависимости от типа взаимодействия. Хотя существует множество методов, которые вы можете добавить в обработчик Proxy, два наиболее распространенных из них — get и set:

- get: вызывается при попытке получить доступ к свойству;
- set: вызывается при попытке изменить свойство.

Эффективно, в конечном итоге будет происходить следующее:

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.013.jpeg)

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.014.jpeg)Вместо того чтобы взаимодействовать с объектом person напрямую, мы будем взаимодействовать с personProxy.

Давайте добавим обработчики к прокси personProxy. При попытке изменить свойство, вызывая метод set у прокси, мы хотим, чтобы прокси регистрировал предыдущее и новое значение свойства. При попытке получить доступ к свойству, вызывая метод get у прокси, мы хотим, чтобы прокси записывал в журнал более читаемое предложение, содержащее ключ и значение свойства.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.015.png)

Отлично! Давайте посмотрим, что происходит, когда мы пытаемся изменить или получить свойство.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.016.jpeg)

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/cocky-bird-rkgyo>*

При обращении к свойству name прокси-сервер возвращает предложение следующего вида: The value of name is John Doe.

При изменении свойства age прокси вернул предыдущее и новое значение этого свойства: Changed age from 42 to 43.

Прокси может быть полезен для добавления **валидации.** Пользователь не должен иметь возможность изменить возраст человека на строковое значение или дать ему пустое имя. Или, если пользователь пытается получить доступ к несуществующему свойству объекта, мы должны сообщить ему об этом.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.017.jpeg)

Давайте посмотрим, что происходит, когда мы пытаемся передать ошибочные значения!

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/focused-rubin-dgk2v>*

Прокси позаботился о том, чтобы мы не модифицировали объект person с ошибочными значениями, что помогает нам сохранять наши данные в чистоте!

**Reflect**

JavaScript предоставляет встроенный объект под названием Reflect, который упрощает манипулирование целевым объектом при работе с прокси.

Раньше мы пытались изменить свойства целевого объекта внутри прокси и получить к ним доступ, непосредственно получая или устанавливая значения с помощью скобочных обозначений. Вместо этого мы можем использовать объект Reflect. Методы объекта Reflect имеют те же имена, что и методы объекта-обработчика.

Вместо того чтобы обращаться к свойствам через obj[prop] или устанавливать свойства через obj[prop] = value, мы можем обращаться к свойствам целевого объекта или изменять их через Reflect.get() и Reflect.set(). Эти методы получают те же аргументы, что и методы объекта-обработчика.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.018.png)

Отлично! Мы можем легко получить доступ и изменить свойства целевого объекта с помощью объекта Reflect.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/gallant-violet-o1hjx>*

Proxy — это мощный способ добавить контроль над поведением объекта. Proxy может использоваться в различных случаях: он может помочь с проверкой, форматированием, уведомлениями или отладкой.

Чрезмерное использование объекта Proxy или выполнение тяжелых операций при каждом вызове метода обработчика может негативно сказаться на производительности вашего приложения. Лучше не использовать proxy в коде, критичном к производительности.

- **Паттерн Provider («Поставщик»)**

*Возможность сделать данные доступными для нескольких дочерних компонентов*

В некоторых случаях мы хотим сделать доступными данные для многих (если не для всех) компонентов приложения. Хотя мы можем передавать данные компонентам с помощью props, это может быть сложно сделать, если почти все компоненты в вашем приложении нуждаются в доступе к значению props.

В итоге мы часто сталкиваемся с так называемым "бурлением props’ов" *(прим. перев. - prop drilling)*, когда мы передаем props далеко вниз по дереву компонентов. Рефакторинг кода, который полагается на props, становится практически невозможным, а узнать, откуда берутся определенные данные, сложно.

Допустим, у нас есть один компонент App, который содержит определенные данные *(прим. перев. - data)*. Дальше по дереву компонентов у нас есть компоненты ListItem, Header и Text, которым нужны эти данные. Чтобы передать эти данные этим компонентам, нам придется пройти через несколько уровней компонентов.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.019.jpeg)

В нашей кодовой базе это выглядело бы примерно следующим образом:

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.020.jpeg)

Передача props таким образом может стать довольно запутанной. Если мы захотим переименовать prop в будущем, нам придется переименовать его во всех компонентах. Чем больше становится ваше приложение, тем сложнее может быть prop drilling. Было бы оптимально, если бы мы могли пропустить все слои компонентов, которым не нужно использовать эти данные *(прим. перев. - data).* Нам нужно иметь что-то, что даст компонентам, которым нужен доступ к ценности данных, прямой доступ к ним, не полагаясь на prop drilling.

Именно здесь нам может помочь **паттерн Provider**! Используя его, мы можем сделать данные доступными для нескольких компонентов. Вместо того чтобы передавать данные на каждом уровне через props, мы можем обернуть все компоненты в Provider. Provider — это компонент высшего порядка, который предоставляет нам объект Context. Мы можем создать объект Context, используя метод createContext, который предоставляет нам React.

Provider получает prop value, в котором можно передать данные дочерним компонентам. Все компоненты, обернутые внутри Provider, будут иметь доступ к значению value prop.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.021.jpeg)

Нам больше не нужно вручную передавать props каждому компоненту! Итак, как компоненты ListItem, Header и Text могут получить доступ к значению данных *(прим. перев. - data)*?

Каждый компонент может получить доступ к данным *(прим. перев. - data)*, используя хук useContext. Этот хук получает контекст, на который ссылаются данные, в данном случае DataContext. Хук useContext позволяет нам читать и записывать данные в объект контекста.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.022.jpeg)

Компонентам, которые не используют данные *(прим. перев. - data)*, вообще не придется иметь с ними дело. Нам больше не нужно беспокоиться о передаче props на несколько уровней вниз через компоненты, которым не нужно значение props, что значительно упрощает рефакторинг.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.023.jpeg)

Паттерн Provider очень полезен для совместного использования глобальных данных. Частым примером использования паттерна Provider является совместное использование состояния пользовательского интерфейса многими компонентами. Допустим, у нас есть простое приложение, которое отображает список.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/busy-oskar-ifz3w>*

Мы хотим, чтобы пользователь мог переключаться между режимами lightmode и darkmode с помощью переключателя. При переключении с тёмного режима на светлый и наоборот, цвет фона и цвет текста должны меняться! Вместо того чтобы передавать текущее значение темы каждому компоненту, мы можем обернуть компоненты в ThemeProvider и передать ему текущие цвета темы.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.024.jpeg)

Поскольку компоненты Toggle и List обернуты внутри ThemeContext Provider, у нас есть доступ к значениям theme и toggleTheme, которые передаются в качестве значения Provider’у.

Внутри компонента Toggle мы можем использовать функцию toggleTheme для соответствующего обновления темы.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.025.jpeg)

Сам компонент List не заботится о текущем значении темы. Однако компонентам ListItem это важно! Мы можем использовать контекст темы непосредственно в ListItem.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.026.png)

Отлично! Нам не нужно передавать данные компонентам, которым неважно текущее значение темы.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/quirky-sun-9djpl>*

**Hooks**

Мы можем создать хук для предоставления контекста компонентам. Вместо того чтобы импортировать useContext и Context в каждый компонент, мы можем использовать хук, который возвращает нужный нам контекст.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.027.png)

Чтобы убедиться, что это валидная тема, давайте выдадим ошибку, если useContext(ThemeContext) вернет фальшивое значение.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.028.png)

Вместо того чтобы оборачивать компоненты непосредственно компонентом ThemeContext.Provider, мы можем создать HOC, который оборачивает компонент для предоставления его значений. Таким образом, мы можем отделить логику контекста от компонентов рендеринга, что улучшает возможность повторного использования Provider.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.029.jpeg)

Каждый компонент, которому необходим доступ к ThemeContext, теперь может просто использовать хук useThemeContext.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.030.png)

Создавая hooks для различных контекстов, можно легко отделить логику Provider’ов от компонентов, которые отображают данные.

**Тематическое исследование**

Некоторые библиотеки предоставляют встроенные Provider’ы, значения которых мы можем использовать в потребляющих компонентах. Хорошим примером этого являются [styled-components](https://styled-components.com/docs/advanced).

*Для понимания этого примера не требуется опыта работы со styled-components.*

Библиотека styled-components предоставляет нам ThemeProvider. Каждый стилизованный компонент будет иметь доступ к значению этого Provider! Вместо того чтобы самим создавать context API, мы можем использовать уже предоставленный нам!

Давайте воспользуемся тем же примером List и обернем компоненты в ThemeProvider, импортированный из библиотеки styled-component.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.031.jpeg)

Вместо того чтобы передавать компоненту ListItem встроенное свойство style, мы сделаем его компонентом styled.li. Поскольку это стилизованный компонент, мы можем получить доступ к значению theme!

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.032.jpeg)

Потрясающе, теперь мы можем легко применять стили ко всем нашим стилизованным компонентам с помощью ThemeProvider!

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/divine-platform-gbuls>*

**Плюсы**

Паттерн Provider /Context API позволяет передавать данные многим компонентам без необходимости вручную передавать их через каждый слой компонента.

Это снижает риск случайного внесения ошибок при рефакторинге кода. Раньше, если впоследствии мы хотели переименовать prop, нам приходилось переименовывать его во всем приложении, где использовалось это значение.

Теперь нам больше не придется иметь дело с переименованием props, которое можно рассматривать как антипаттерн. Раньше было трудно понять поток данных приложения, поскольку не всегда было понятно, откуда берутся определенные значения props. С паттерном Provider нам больше не нужно без необходимости передавать props компоненту, которому эти данные не нужны.

Поддерживать некое глобальное состояние становится проще благодаря паттерну Provider, поскольку мы можем предоставить компонентам доступ к этому глобальному состоянию.

**Минусы**

В некоторых случаях чрезмерное использование паттерна Provider может привести к проблемам с производительностью. Все компоненты, потребляющие контекст, заново отображаются при каждом изменении состояния.

Давайте рассмотрим пример. У нас есть простой счетчик, значение которого увеличивается каждый раз, когда мы нажимаем на кнопку Increment в компоненте Button. У нас также есть кнопка Reset в компоненте Reset, которая сбрасывает счетчик обратно на 0.

Однако при нажатии на кнопку Increment можно увидеть, что не только счетчик изменяется. Дата в компоненте Reset также изменяется!

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/provider-pattern-2-4ke0w>*

Компонент Reset также выполнил повторный рендеринг, поскольку он потреблял useCountContext. В небольших приложениях это не будет иметь большого значения. В больших приложениях передача часто обновляемого значения многим компонентам может негативно сказаться на производительности.

Чтобы убедиться, что компоненты не потребляют Provider, содержащий ненужные значения, которые могут обновляться, вы можете создать несколько Provider’ов для каждого отдельного случая использования.

- **Паттерн Prototype («Прототип»)**

*Совместное использование свойств многими объектами одного типа*

Паттерн Prototype — это полезный способ совместного использования свойств многими объектами одного типа. Prototype — это нативный объект JavaScript, и к нему могут обращаться объекты через цепочку prototype.

В наших приложениях нам часто приходится создавать множество объектов одного типа. Полезный способ сделать это — создать несколько экземпляров класса ES6. Допустим, мы хотим создать много собак! В нашем примере собаки умеют не так уж много: у них просто есть имя, и они могут лаять *(прим. перев. - метод bark)*!

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.033.jpeg)

Обратите внимание, что конструктор содержит свойство name, а сам класс содержит свойство bark. При использовании классов ES6 все свойства, определенные для самого класса, в данном случае bark, автоматически добавляются в prototype.

Мы можем увидеть prototype непосредственно через доступ к свойству prototype конструктора или через свойство \_\_proto\_\_ любого экземпляра.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.034.png)

Значение \_\_proto\_\_ в любом экземпляре конструктора — это прямая ссылка на prototype конструктора! Всякий раз, когда мы пытаемся получить доступ к свойству объекта, которое не существует непосредственно в объекте, JavaScript ***спускается вниз по цепочке prototype***, чтобы проверить, доступно ли свойство в цепочке prototype.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.035.jpeg)

Модель prototype очень эффективна при работе с объектами, которые должны иметь доступ к одним и тем же свойствам. Вместо того чтобы каждый раз создавать дубликат свойства, мы можем просто добавить свойство в prototype, поскольку все экземпляры имеют доступ к объекту-prototype.

Поскольку все экземпляры имеют доступ к prototype, легко добавлять свойства к prototype даже после создания экземпляров.

Скажем, наши собаки должны уметь не только лаять, но и играть! Мы можем сделать это возможным, добавив свойство play в prototype.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/eloquent-turing-v42kr>*

Термин **«цепочка прототипов»** *(прим. перев. - **prototype chain**)* указывает на то, что здесь может быть более одного шага. Действительно! До сих пор мы видели только то, как можно получить доступ к свойствам, которые непосредственно доступны на первом объекте, на который ссылается \_\_proto\_\_. Однако у самих prototype тоже есть объект \_\_proto\_\_.

Давайте создадим другой тип собаки, суперсобаку! Эта собака должна унаследовать все от обычной собаки, но она также должна уметь летать. Мы можем создать суперсобаку, расширив класс Dog и добавив метод fly.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.036.png)

Давайте создадим летающую собаку по имени Дейзи, и пусть она лает и летает! *С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/hopeful-poitras-vuch6>*

У нас есть доступ к методу bark, поскольку мы расширили класс Dog. Значение

\_\_proto\_\_ в prototype SuperDog указывает на объект Dog.prototype!

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.037.jpeg)

Становится понятно, почему это называется *цепочкой* prototype: когда мы пытаемся получить доступ к свойству, которое недоступно непосредственно

объекту, JavaScript рекурсивно обходит все объекты, на которые указывает

\_\_proto\_\_, пока не найдет это свойство!

**Object.create**

Метод Object.create позволяет нам создать новый объект, которому мы можем явно передать значение его prototype.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.038.png)

Хотя у самого pet1 нет никаких свойств, у него есть доступ к свойствам цепочки его prototype! Поскольку мы передали объект dog в качестве prototype pet1, мы можем получить доступ к свойству bark.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/funny-wing-w38zk>*

Отлично! Object.create — это простой способ позволить объектам напрямую наследовать свойства от других объектов, указывая prototype вновь создаваемого объекта. Новый объект может получить доступ к новым свойствам, пройдя по цепочке prototype.

Паттерн Prototype позволяет нам легко позволить объектам получать доступ к свойствам других объектов и наследовать их. Поскольку цепочка prototype позволяет нам получить доступ к свойствам, которые не определены непосредственно в самом объекте, мы можем избежать дублирования методов и свойств, тем самым уменьшая объем используемой памяти.

- **Контейнерный/презентационный паттерн**

*Обеспечьте разделение проблем, отделив представление от логики приложения*

В React одним из способов обеспечения **разделения задач** является использование паттерна **«контейнер/представление»**. С помощью этого паттерна мы можем отделить представление от логики приложения.

Допустим, мы хотим создать приложение, которое получает 6 изображений собак и отображает их на экране.

В идеале мы хотим обеспечить **разделения задач**, разделив этот процесс на две части:

1. **Презентационные компоненты:** Компоненты, которые заботятся о том, как *(прим. перев. - **вопрос - “как”**)* данные будут показаны пользователю. В данном примере это рендеринг списка изображений собак.
1. **Контейнерные компоненты:** Компоненты, которые заботятся о том, какие данные *(прим. перев. - **вопрос - “что”**)* показываются пользователю. В данном примере это получение изображений собак.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.039.jpeg)

Получение изображений собак относится к **логике приложения**, в то время как отображение изображений относится только к **представлению.**

**Презентационный компонент / Presentational Component**

Презентационный компонент получает свои данные через props. Его основная функция

- только **отображать полученные данные** так, как мы хотим, включая стили, не изменяя эти данные.

Давайте рассмотрим пример с отображением изображений собак. При отображении изображений собак мы просто хотим отобразить каждое изображение собаки, полученное из API, и отобразить эти изображения. Для этого мы можем создать функциональный компонент, который получает данные через props и отображает полученные данные.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/sleepy-murdock-if0ec>*

Компонент DogImages является презентационным компонентом. Презентационные компоненты обычно не имеют состояния: они не содержат собственного состояния React, если только состояние не нужно им для целей пользовательского интерфейса. Данные, которые они получают, не изменяются самими презентационными компонентами.

Презентационные компоненты получают свои данные от **компонентов-контейнеров.**

**Контейнерный компонент / Container Components**

Основная функция контейнерных компонентов заключается в **передаче данных** презентационным компонентам, которые они содержат. Сами контейнерные компоненты обычно не отображают никаких других компонентов, кроме презентационных компонентов, которые заботятся об их данных. Поскольку они сами ничего не отображают, они обычно не содержат и стилей.

В нашем примере мы хотим передать изображения собак презентационному компоненту DogsImages. Прежде чем мы сможем это сделать, нам нужно получить изображения из внешнего API. Нам нужно создать **компонент-контейнер**, который будет получать эти данные и передавать их презентационному компоненту DogsImages для отображения на экране.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/sleepy-murdock-if0ec>*

Объединение этих двух компонентов вместе позволяет разделить логику работы приложения и представление.

**Hooks**

Во многих случаях паттерн «контейнер/представление» можно заменить на React Hooks. Введение хуков упростило для разработчиков добавление состояния без необходимости использования компонента-контейнера для обеспечения этого состояния.

Вместо того чтобы располагать логику получения данных в компоненте DogImagesContainer, мы можем создать пользовательский хук, который будет получать изображения и возвращать массив собак.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.040.png)

Используя этот хук, нам больше не нужно, чтобы оберточный компонент-контейнер DogImagesContainer получал данные и отправлял их в презентационный компонент DogImages. Вместо этого мы можем использовать этот хук непосредственно в нашем презентационном компоненте DogImages!

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/rough-brook-tzp7i>*

Используя хук useDogImages, мы так же отделили логику приложения от представления. Мы просто используем возвращаемые данные из хука useDogImages, не изменяя эти данные в компоненте DogImages.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.041.jpeg)

Hooks позволяют легко разделить логику и представление в компоненте, подобно шаблону «контейнер/представление». Это избавляет нас от дополнительного слоя, который был необходим для того, чтобы обернуть презентационный компонент внутри компонента-контейнера.

**Плюсы**

Использование паттерна «контейнер/представление» имеет много преимуществ. Данный паттерн поощряет **разделение задач.** Презентационные компоненты могут быть чистыми функциями, отвечающими за пользовательский интерфейс, в то время как контейнерные компоненты отвечают за состояние и данные приложения. Это позволяет легко обеспечить **разделение задач.**

Презентационные компоненты легко использовать повторно, поскольку они просто отображают данные, не изменяя их. Мы можем повторно использовать презентационные компоненты во всем нашем приложении для различных целей. Поскольку презентационные компоненты не изменяют логику приложения, внешний вид презентационных компонентов может быть легко изменен кем-то без знания кодовой базы, например, дизайнером. Если презентационный компонент был повторно использован во многих частях приложения, изменение может быть последовательным во всем приложении.

Тестировать презентационные компоненты легко, поскольку они обычно являются чистыми функциями. Мы знаем, что будут отображать компоненты в зависимости от передаваемых данных без необходимости имитировать хранилище данных.

**Минусы**

Паттерн «контейнер/представление» позволяет легко отделить логику приложения от логики рендеринга. Однако hooks позволяют достичь того же результата без использования данного паттерна и без необходимости переписывать функциональный компонент без состояния в компонент класса.

Обратите внимание, что сегодня нам больше не нужно создавать компоненты класса для использования состояния.

Хотя мы все еще можем использовать данный паттерн, даже с React Hooks, он может стать излишеством в небольших приложениях.

- **Паттерн Observer («Наблюдатель»)**

*Позволяет использовать наблюдаемые объекты для уведомления подписчиков о наступлении события*

С помощью **паттерна Observer** мы можем подписать определенные объекты — **observers** *(прим. перев. - наблюдатели)* — на другой объект, называемый **observable** *(прим. перев. - наблюдаемым)*. Когда происходит событие, observable уведомляет всех своих observers!

Объект observable обычно содержит 3 важные части:

- observers: массив наблюдателей, которые будут получать уведомления при наступлении определенного события;
- subscribe(): метод для добавления наблюдателей в список наблюдателей;
- unsubscribe(): метод для удаления наблюдателей из списка наблюдателей;
- notify(): метод для уведомления всех наблюдателей при наступлении определенного события.

Отлично, давайте создадим observable! Простым способом создания является использование класса ES6.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.042.jpeg)

Потрясающе! Теперь мы можем добавлять наблюдателей в список observers с помощью метода subscribe, удалять наблюдателей с помощью метода unsubscribe и уведомлять всех подписавшихся с помощью метода notify.

Давайте создадим что-нибудь с помощью этого класса Observable. У нас есть очень простое приложение, состоящее только из двух компонентов: кнопки *(прим. перев. - Button)* и переключателя *(прим. перев. - Switch).*

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.043.png)

Мы хотим отслеживать **взаимодействие пользователя** с приложением. Каждый раз, когда пользователь нажимает на кнопку или переключает переключатель, мы хотим регистрировать это событие с меткой времени. Помимо регистрации, мы также хотим создать всплывающее уведомление, которое будет появляться каждый раз, когда происходит событие!

Каждый раз, когда пользователь вызывает функцию handleClick или handleToggle, эти функции вызывают метод notify в observer. Метод notify уведомляет всех подписчиков данными, которые были переданы функцией handleClick или handleToggle!

Сначала создадим функции logger и toastify. Эти функции будут получать данные от метода notify.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.044.jpeg)

В настоящее время функции logger и toastify не знают об observable: observable не может их уведомить! Чтобы сделать их наблюдателями *(прим. перев. - observers),* мы должны подписаться на них, используя метод subscribe в observable!

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.045.jpeg)

При возникновении любого события функции logger и toastify будут получать уведомления. Теперь нам осталось реализовать функции, которые действительно уведомляют observable: функции handleClick и handleToggle! Эти функции должны вызывать метод notify в observable и передавать данные, которые должны получать наблюдатели *(прим. перев. - observers).*

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.046.jpeg)

Потрясающе! Мы только что завершили весь поток: handleClick и handleToggle вызывают метод notify на наблюдателе с данными, после чего наблюдатель уведомляет подписчиков: в данном случае функции logger и toastify.

Когда пользователь будет взаимодействовать с одним из компонентов, функции logger и toastify получат уведомления с данными, которые мы передали в метод notify!

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/quizzical-sinoussi-md8k5>*

Хотя мы можем использовать паттерн Observer разными способами, он может быть очень полезен при работе с **асинхронными, основанными на событиях данными.** Возможно, вы хотите, чтобы определенные компоненты получали уведомления о завершении загрузки определенных данных или о том, что пользователи отправили новые сообщения на доску объявлений, и все остальные пользователи должны получить уведомление.

**Изучение конкретного случая**

Популярной библиотекой, использующей паттерн Observer, является RxJS.

*«ReactiveX объединяет паттерн Observer с паттерном Iterator и функциональное программирование с коллекциями, чтобы удовлетворить потребность в идеальном способе управления последовательностями событий. – RxJS»*

С помощью RxJS мы можем создавать наблюдаемых *(прим. перев. - observables)* и подписываться на определенные события! Давайте рассмотрим пример, описанный в документации, который регистрирует, перетащил ли пользователь документ или нет.

*С примером можно ознакомиться по ссылке: <https://codesandbox.io/embed/stoic-turing-kqq9z>*

В RxJS есть масса встроенных функций и примеров, которые работают с паттерном Observer.

**Плюсы**

Использование паттерна Observer - это отличный способ обеспечить **разделение задач** и принцип единственной ответственности. Объекты-наблюдатели не связаны жестко с наблюдаемым объектом и могут быть отвязаны в любое время. Наблюдаемый объект отвечает за мониторинг событий, а наблюдатели просто обрабатывают полученные данные.

**Минусы**

Если наблюдатель становится слишком сложным, он может вызвать проблемы с производительностью при оповещении всех подписчиков.

- **Паттерн «Модуль»**

*Разделение кода на более мелкие части, пригодные для повторного использования*

По мере роста вашего приложения и кодовой базы становится все более важным сохранять код поддерживаемым и разделенным. Паттерн модульности позволяет разделить код на более мелкие многократно используемые части.

Помимо этого, модули позволяют вам сохранять определенные значения в файле конфиденциальными. Объявления внутри модуля по умолчанию привязаны (инкапсулированы) к этому модулю. Если мы явно не экспортируем определенное значение, оно будет недоступно за пределами данного модуля. Это снижает риск коллизии имен для значений, объявленных в других частях вашей кодовой базы, поскольку эти значения недоступны в глобальной области видимости.

**Модули ES2015**

В ES2015 появились встроенные модули JavaScript. Модуль — это файл, содержащий код JavaScript, с некоторыми отличиями в поведении по сравнению с обычным скриптом.

Рассмотрим пример модуля под названием math.js, содержащего математические функции.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/design-patterns10-44n1k>*

У нас есть файл math.js, содержащий простую математическую логику. У нас есть функции, которые позволяют пользователям складывать, умножать, вычитать и получать квадрат передаваемых значений.

Однако, мы хотим не просто использовать эти функции в файле math.js, мы хотим иметь возможность ссылаться на них в файле index.js! В настоящее время в файле index.js возникает ошибка: в файле index.js нет функций add, subtract, multiply или square. Мы пытаемся ссылаться на функции, которых нет в файле index.js.

Для того чтобы сделать функции из math.js доступными для других файлов, мы должны сначала экспортировать их. Чтобы экспортировать код из модуля, мы можем использовать ключевое слово export. Одним из способов экспорта функций является использование именованных экспортов: мы можем просто добавить ключевое слово export перед теми частями, которые мы хотим публично раскрыть. В данном случае мы хотим добавить ключевое слово export перед каждой функцией, поскольку index.js должен иметь доступ ко всем четырем функциям.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.047.png)

Мы только что сделали экспортируемыми функции add, multiply, subtract и square! Однако просто экспортировать значения из модуля недостаточно, чтобы сделать их общедоступными для всех файлов. Чтобы иметь возможность использовать экспортированные значения из модуля, необходимо явно импортировать их в файл, который должен на них ссылаться.

Мы должны импортировать значения поверх файла index.js, используя ключевое слово import. Чтобы javascript знал, из какого модуля мы хотим импортировать эти функции, нам нужно добавить значение from и относительный путь к модулю.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.048.png)

Мы только что импортировали четыре функции из модуля math.js в файл index.js! Давайте попробуем проверить, можем ли мы теперь использовать эти функции!

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/holy-cookies-7t2cp>*

Ошибка исчезла, теперь мы можем использовать экспортированные значения из модуля!

Большим преимуществом модулей является то, что мы имеем доступ только к тем значениям, которые мы явно экспортировали с помощью ключевого слова export. Значения, которые мы явно не экспортировали с помощью ключевого слова export, доступны только в рамках данного модуля.

Давайте создадим значение, на которое можно будет ссылаться только в файле math.js, под названием privateValue.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.049.jpeg)

Обратите внимание, что мы не добавили ключевое слово export перед privateValue. Поскольку мы не экспортировали переменную privateValue, у нас нет доступа к этому значению за пределами модуля math.js!

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.050.png)Сохраняя значение частным для модуля, снижается риск случайного загрязнения глобальной области видимости. Вам не нужно бояться, что вы случайно перезапишете значения, созданные разработчиками, использующими ваш модуль, которые могли иметь то же имя, что и ваше частное значение: это предотвращает коллизии именования.

Иногда названия экспортируемых значений могут пересекаться с местными значениями.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.051.png)

В данном случае у нас есть функции add и multiply в файле index.js. Если бы мы импортировали значения с одинаковыми именами, это привело бы к столкновению имен: функции add и multiply уже были объявлены! К счастью, мы можем переименовать импортированные значения, используя ключевое слово as. Давайте переименуем импортированные функции add и multiply в addValues и multiplyValues.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.052.png)

Помимо именованных экспортов, которые представляют собой экспорты, определяемые только ключевым словом export, вы также можете использовать экспорт по умолчанию. В каждом модуле может быть только **один** экспорт по умолчанию. Давайте сделаем функцию add экспортом по умолчанию, а остальные функции оставим именованными экспортами. Мы можем экспортировать значение по умолчанию, добавив export default перед значением.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.053.png)

Разница между именованным экспортом и экспортом по умолчанию заключается в том, как значение экспортируется из модуля, фактически изменяя способ импорта значения.

Ранее мы должны были использовать скобки для именованного экспорта: import { module } from 'module'. С помощью экспорта по умолчанию мы можем импортировать значение без скобок: import module from 'module'.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.054.png)

Значение, которое было импортировано из модуля без скобок, всегда является значением экспорта по умолчанию, если существует экспорт по умолчанию. Поскольку JavaScript знает, что это значение всегда является значением, экспортированным по умолчанию, мы можем дать импортированному значению по умолчанию другое имя, отличное от имени, с которым мы его экспортировали. Вместо импорта функции add с именем add мы можем назвать ее, например, addValues.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.055.png)

Даже если мы экспортировали функцию add, мы можем импортировать ее, называя как угодно, поскольку JavaScript знает, что вы импортируете экспорт по умолчанию.

Мы также можем импортировать все экспорты из модуля, то есть все именованные экспорты и экспорт по умолчанию, используя звездочку \* и указывая имя, под которым мы хотим импортировать модуль. Значение импорта равно объекту, содержащему все импортируемые значения. Допустим, я хочу импортировать весь модуль как math.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.056.png)

Импортированные значения являются свойствами объекта math.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.057.png)

В данном случае мы импортируем все экспорты из модуля. Будьте осторожны при выполнении этого действия, так как в конечном итоге вы можете импортировать ненужные значения.

Использование \* только импортирует все экспортированные значения. Значения, закрытые для модуля, по-прежнему недоступны в файле, который импортирует модуль, если только вы явно не экспортировали их.

**React**

При разработке приложений на React часто приходится иметь дело с большим количеством компонентов. Вместо того чтобы писать все эти компоненты в одном файле, мы можем разделить компоненты в их собственных файлах, по сути, создав модуль для каждого компонента.

У нас есть базовый todo-список, содержащий список *(прим. перев. - list)*, элементы списка *(прим. перев. - list items),* поле ввода *(прим. перев. - input field)* и кнопку *(прим. перев. - button).*

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/heuristic-brattain-ipcyb>*

Мы просто разделим наши компоненты на отдельные файлы:

- TodoList.js для компонента List;
- Button.js для настроенного компонента Button;
- Input.js для настроенного компонента Input.

Во всем приложении мы не хотим использовать стандартные компоненты Button и Input, импортированные из библиотеки material-ui. Вместо этого мы хотим использовать нашу пользовательскую версию компонентов, добавив к ним пользовательские стили, определенные в объекте styles в их файлах. Вместо того чтобы каждый раз импортировать компонент Button и Input по умолчанию в наше приложение и добавлять к нему пользовательские стили снова и снова, теперь мы можем просто импортировать компонент Button и Input по умолчанию один раз, добавить стили и экспортировать наш пользовательский компонент.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/design-patterns12-ipcyb>*

Обратите внимание, что у нас есть объект под названием style и в Button.js, и в Input.js. Поскольку это значение является модульно-скопированным, мы можем повторно использовать имя переменной без риска столкновения имен.

**Динамический импорт**

При импорте всех модулей в верхней части файла все модули загружаются раньше, чем остальная часть файла. В некоторых случаях нам нужно импортировать модуль только на основании определенного условия. С помощью **динамического импорта** мы можем импортировать модули по требованию.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.058.png)

Давайте динамически импортируем пример math.js, использованный в предыдущих параграфах.

Модуль будет загружен только в том случае, если пользователь нажмет на кнопку. *С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/green-sound-j60fl>*

Динамически импортируя модули, мы можем сократить время загрузки страницы. Мы должны **загружать, разбирать и компилировать** только тот код, который действительно нужен пользователю, когда он в нем нуждается.

Помимо возможности импортировать модули по требованию, функция import() может принимать выражение. Это позволяет нам передавать шаблонные литералы, чтобы динамически загружать модули на основе заданного значения.

В приведенном выше примере модуль date.js импортируется только в том случае, если пользователь нажимает на кнопку Click to load dates. Модуль date.js импортирует сторонний модуль moment, который импортируется только при загрузке модуля date.js. Если пользователю не нужно показывать даты, мы можем вообще не загружать эту стороннюю библиотеку.

Каждое изображение загружается после того, как пользователь нажимает на кнопку Click to load image. Изображения представляют собой локальные файлы .png, которые загружаются в зависимости от значения num, которое мы передаем в строку.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.059.png)

Таким образом, мы не зависим от жестко закодированных путей к модулям. Это добавляет гибкости в том, как вы можете импортировать модули на основе пользовательского ввода, данных, полученных из внешнего источника, результата функции и так далее.

С помощью паттерна модуль мы можем инкапсулировать части нашего кода, которые не должны быть открытыми. Это предотвращает случайное столкновение имен и загрязнение глобальной области видимости, что делает работу с многочисленными зависимостями и пространствами имен менее рискованной.

Для того чтобы иметь возможность использовать модули ES2015 во всех средах выполнения JavaScript, необходим транспилятор, такой как Babel.

- **Паттерн «Миксин»**

*Добавление функциональности к объектам или классам без наследования*

Миксин — это объект, который мы можем использовать для добавления многократно используемой функциональности к другому объекту или классу без использования наследования. Мы не можем использовать миксины сами по себе: их единственная цель — добавить функциональность к объектам или классам без наследования. Допустим, для нашего приложения нам нужно создать несколько собак. Однако у основной собаки, которую мы создаем, нет никаких свойств, кроме свойства name.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.060.png)Собака должна уметь больше, чем просто иметь имя. Она должна уметь лаять, вилять хвостом и играть! Вместо того чтобы добавлять это непосредственно к собаке, мы можем создать миксин, который предоставит нам свойства bark, wagTail и play.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.061.png)

Мы можем добавить миксин dogFunctionality к прототипу Dog с помощью метода Object.assign. Этот метод позволяет нам добавлять свойства к целевому объекту: Dog.prototype в данном случае. Каждый новый экземпляр Dog будет иметь доступ к свойствам dogFunctionality, поскольку они добавлены к прототипу Dog!

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.062.jpeg)

Давайте создадим нашего первого питомца, pet1, по имени Дейзи. Поскольку мы только что добавили миксин dogFunctionality к прототипу Dog, Дейзи должна уметь ходить, вилять хвостом и играть!

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.063.png)

Отлично! Миксины позволяют нам легко добавлять пользовательскую функциональность к классам или объектам без использования наследования.

Хотя мы можем добавлять функциональность с помощью миксинов без наследования, сами миксины могут использовать наследование!

Большинство млекопитающих (кроме дельфинов... и, возможно, еще некоторых) могут ходить и спать. Собака — это млекопитающее, и она должна уметь ходить и спать! Давайте создадим миксин animalFunctionality, который добавит свойства ходить и спать.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.064.png)

Мы можем добавить эти свойства к прототипу dogFunctionality, используя Object.assign. В данном случае целевым объектом является dogFunctionality.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.065.jpeg)

Отлично! Теперь любой новый экземпляр Dog может получить доступ к методам walk и sleep.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/zen-franklin-gvusj>*

Пример миксина в реальном мире можно увидеть на примере интерфейса Window в среде браузера. Объект Window реализует многие свои свойства из миксинов WindowOrWorkerGlobalScope и WindowEventHandlers, которые позволяют нам иметь доступ к таким свойствам, как setTimeout и setInterval, indexedDB и isSecureContext. Поскольку это миксин, который используется только для добавления функциональности объектам, вы не сможете создавать объекты типа WindowOrWorkerGlobalScope.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/epic-dream-p8zhf>*

**React (до ES6)**

Миксины часто использовались для добавления функциональности в компоненты React до внедрения классов ES6. Команда React [не рекомендует использовать](https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html) [миксины](https://reactjs.org/blog/2016/07/13/mixins-considered-harmful.html), поскольку они легко добавляют ненужную сложность компоненту, затрудняя его поддержку и повторное использование. Вместо этого команда

React [поощряет использование компонентов высшего порядка](https://medium.com/@dan_abramov/mixins-are-dead-long-live-higher-order-components-94a0d2f9e750), которые теперь можно заменить на Hooks.

Миксины позволяют нам легко добавлять функциональность к объектам без наследования, внедряя функциональность в прототип объекта. Изменение прототипа объекта считается плохой практикой, так как это может привести к загрязнению прототипа и неопределенности относительно происхождения наших функций.

- **Паттерн «Mediator/Middleware»**

*Возможность использования центрального объекта-посредника для обработки связи между компонентами*

Паттерн медиатор позволяет компонентам взаимодействовать друг с другом через центральную точку — медиатор. Вместо того чтобы напрямую разговаривать друг с другом, посредник получает запросы и отправляет их дальше! В JavaScript медиатор часто представляет собой не что иное, как литерал объекта или функцию.

Можно сравнить эту схему с отношениями между авиадиспетчером и пилотом. Вместо того чтобы пилоты общались друг с другом напрямую, что, вероятно, привело бы к хаосу, пилоты общаются с авиадиспетчером. Авиадиспетчер следит за тем, чтобы все самолеты получали необходимую информацию для безопасного полета, не задевая другие самолеты.

Хотя мы, надеюсь, не управляем самолетами в JavaScript, нам часто приходится иметь дело с многонаправленными данными между объектами. При большом количестве компонентов связь между ними может стать довольно запутанной.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.066.jpeg)

Вместо того чтобы позволить каждому объекту напрямую общаться с другими объектами, что приводит к отношениям «многие-ко-многим», запросы объекта обрабатываются посредником. Посредник обрабатывает запрос и отправляет его туда, куда нужно.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.067.jpeg)

Хорошим примером использования паттерна посредника является чат! Пользователи в чате не будут общаться друг с другом напрямую. Вместо этого чат служит посредником между пользователями.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.068.jpeg)

Мы можем создавать новых пользователей, подключенных к чату. Каждый экземпляр пользователя имеет метод send, который мы можем использовать для отправки сообщений.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/late-glade-7gjmr>*

**Исследование конкретного случая**

[Express.js](https://expressjs.com/) — это популярный серверный фреймворк для веб-приложений. Мы можем добавить обратные вызовы к определенным маршрутам, к которым пользователь может получить доступ.

Скажем, мы хотим добавить заголовок к запросу, если пользователь обращается к корню '/'. Мы можем добавить этот заголовок в middleware callback *(прим. перев. - промежуточный обратный вызов).*

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.069.png)

Метод next вызывает следующий обратный вызов в цикле запрос-ответ. По сути, мы создаем цепочку middleware функций, которые находятся между запросом и ответом, или наоборот.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.070.jpeg)

Добавим еще одну middleware функцию, которая проверяет, правильно ли был добавлен test-заголовок. Изменение, добавленное предыдущей middleware функцией, будет видно во всей цепочке.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.071.jpeg)

Отлично! Мы можем отслеживать и изменять объект запроса на всем пути к ответу через одну или несколько middleware функций.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/express-js-0e4yr>*

Каждый раз, когда пользователь обращается к корневой конечной точке '/', будут вызываться два middleware callbacks.

Паттерн middleware позволяет нам упростить отношения «многие-ко-многим» между объектами, позволяя всем коммуникациям проходить через одну центральную точку.

- **Паттерн «НОС»**

*Возможность передачи многократно используемую логику в качестве props компонентам по всему приложению*

В нашем приложении мы часто хотим использовать одну и ту же логику в нескольких компонентах. Эта логика может включать применение определенного стиля к компонентам, требование авторизации или добавление глобального состояния.

Одним из способов повторного использования одной и той же логики в нескольких компонентах является паттерн компонентов высшего порядка *(прим. перев. - **higher order component**).* Этот паттерн позволяет нам повторно использовать логику компонентов во всем приложении.

Компонент высшего порядка (HOC) — это компонент, который получает другой компонент. HOC содержит определенную логику, которую мы хотим применить к компоненту, передаваемому в качестве параметра. После применения этой логики HOC возвращает элемент с дополнительной логикой.

Допустим, мы всегда хотели добавить определенный стиль к нескольким компонентам в нашем приложении. Вместо того чтобы каждый раз локально создавать объект стиля, мы можем просто создать HOC, который добавляет объекты стиля к компоненту, который мы ему передаем.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.072.jpeg)

Мы только что создали компоненты StyledButton и StyledText, которые являются модифицированными версиями компонента Button и Text. Теперь они оба содержат стиль, который был добавлен в HОС withStyles!

Давайте посмотрим на тот же пример DogImages, который ранее использовался в паттерне Container/Presentational! Приложение не делает ничего другого, кроме как выводит список изображений собак, полученных из API.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/s/hoc-pattern-1-tzp7i?from-embed>*

Давайте немного улучшим пользовательский опыт. Когда мы получаем данные, мы хотим показать пользователю экран "Loading...". Вместо того чтобы добавлять данные в компонент DogImages напрямую, мы можем использовать компонент высшего порядка, который добавит эту логику за нас.

Давайте создадим HOC под названием withLoader. HOC должен получать компонент и возвращать этот компонент. В данном случае HOC withLoader должен получить элемент, который должен отображать Loading... до тех пор, пока данные не будут получены.

Давайте создадим минимальную версию HOC withLoader, которую мы хотим использовать!

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.073.png)

Однако, мы не хотим просто возвращать полученный элемент. Вместо этого мы хотим, чтобы этот элемент содержал логику, которая сообщит нам, загружаются ли еще данные или нет.

Чтобы сделать withLoader HOC очень многоразовым, мы не будем жестко кодировать URL API Dog в этом компоненте. Вместо этого мы можем передать URL в качестве аргумента в withLoader HOC, так что этот загрузчик можно использовать в любом компоненте, которому нужен индикатор загрузки при получении данных из другой конечной точки API.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.074.png)

HOC возвращает элемент в виде функционального компонента props => {} в данном случае, к которому мы хотим добавить логику, позволяющую нам отобразить текст с Loading..., поскольку данные все еще собираются. Как только данные будут извлечены, компонент должен передать извлеченные данные в качестве props.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/withloader-rslq4>*

Отлично! Мы только что создали HOC, который может принимать любой компонент и url.

1. В хуке useEffect HOC withLoader извлекает данные из конечной точки API, которую мы передаем в качестве значения url. Пока данные еще не вернулись, мы возвращаем элемент, содержащий текст Loading....
1. Как только данные были получены, мы устанавливаем значение data равным полученным данным. Поскольку data больше не является null, мы можем отобразить элемент, который мы передали HOC!

Итак, как мы можем добавить это поведение в наше приложение, чтобы оно действительно показывало индикатор Loading... в списке DogImages?

В DogImages.js мы больше не хотим просто экспортировать обычный компонент DogImages. Вместо этого мы хотим экспортировать "обернутый" withLoading HOC вокруг компонента DogImages.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.075.png)

HOC withLoader также ожидает url, чтобы знать, с какой конечной точки получать данные. В данном случае мы хотим добавить конечную точку API Dog.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.076.png)

Поскольку HOC withLoader вернул элемент с дополнительным data prop, в данном случае DogImages, мы можем получить доступ к data prop в компоненте DogImages. *С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/withloader-rslq4>*

Отлично! Теперь мы видим экран "Loading…" во время получения данных.

Паттерн компонента высшего порядка позволяет нам предоставлять одну и ту же логику нескольким компонентам, сохраняя всю логику в одном месте. HOC withLoader не заботится о компоненте или url, который он получает: если это

действительный компонент и действительная конечная точка API, он просто передаст данные из этой конечной точки API компоненту, который мы передаем.

**Композиция**

Мы также можем **составить** несколько компонентов высшего порядка. Допустим, мы также хотим добавить функциональность, которая показывает текстовое поле Hovering!, когда пользователь наводит курсор на список DogImages.

Нам нужно создать HOC, который предоставляет элемент, которому мы передаем prop наведения. На основе этого prop мы можем условно отобразить текстовое поле в зависимости от того, навел ли пользователь курсор на список DogImages.

Теперь мы можем обернуть HOC withHover вокруг HOC withLoader.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/withhover-withloader-whhh0>*

Элемент DogImages теперь содержит все props, которые мы передали с помощью withHover и withLoader. Теперь мы можем условно отобразить текстовое поле Hovering! в зависимости от того, является ли значение prop hovering true или false.

*«Известной библиотекой, использующей для композиции HOC, является [recompose](https://github.com/acdlite/recompose). Поскольку HOC в значительной степени можно заменить на React Hooks, библиотека recompose больше не поддерживается, поэтому в этой статье она рассматриваться не будет».*

**Hooks**

В некоторых случаях мы можем заменить паттерн HOC на хуки React.

Давайте заменим HOC withHover на хук useHover. Вместо того чтобы иметь компонент высшего порядка, мы экспортируем хук, который добавляет слушателя событий mouseOver и mouseLeave к элементу. Мы больше не можем передавать элемент, как это было в HOC. Вместо этого мы вернем ссылку из хука, который должен получить события mouseOver и mouseLeave.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/usehover-withloader-npo50>*

Хук useEffect добавляет слушателя событий к компоненту и устанавливает значение hovering в true или false, в зависимости от того, наведен ли пользователь в данный момент на элемент. Оба значения — ref и hovering — должны быть возвращены из хука: ref — для добавления ссылки на компонент, который должен получать события mouseOver и mouseLeave, а hovering — для условного отображения текстового поля Hovering!

Вместо того чтобы обертывать компонент DogImages HOC withHover, мы можем использовать хук useHover прямо внутри компонента DogImages.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/usehover-withloader-npo50>*

Отлично! Вместо того чтобы оборачивать компонент DogImages компонентом withHover, мы можем просто использовать хук useHover непосредственно в компоненте.

Вообще говоря, React Hooks не заменяют паттерн HOC.

*«В большинстве случаев Hooks будет достаточно и поможет уменьшить вложенность в вашем дереве»,* - [React Docs](https://reactjs.org/docs/hooks-faq.html#do-hooks-replace-render-props-and-higher-order-components)

Как говорится в документации React, использование Hooks может уменьшить глубину дерева компонентов. Используя паттерн HOC, легко получить глубоко вложенное дерево компонентов.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.077.png)

Добавляя Hook непосредственно к компоненту, нам больше не нужно оборачивать компоненты.

Использование компонентов высшего порядка позволяет предоставлять одну и ту же логику многим компонентам, сохраняя ее в одном месте. Hooks позволяют нам добавлять пользовательское поведение изнутри компонента, что потенциально может увеличить риск появления ошибок по сравнению с паттерном HOC, если множество компонентов полагаются на это поведение.

**Лучшие случаи использования HOC:**

- Одно и то же нестандартное поведение должно использоваться многими компонентами во всем приложении.
- Компонент может работать автономно, без дополнительной пользовательской логики.

**Лучшие случаи использования hooks:**

- Поведение должно быть настроено для каждого компонента, который его использует.
- Поведение не распространяется по всему приложению, его использует только один или несколько компонентов.
- Поведение добавляет множество свойств компоненту.

**Исследование конкретного случая**

Некоторые библиотеки, которые полагались на паттерн HOC, добавили поддержку Hooks после релиза. Хорошим примером этого является [Apollo Client.](https://www.apollographql.com/docs/react)

*«Для понимания этого примера не требуется опыт работы с Apollo Client».* Одним из способов использования Apollo Client является компонент высшего порядка graphql().

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/apollo-hoc-hooks-n3td8>*

С помощью graphql() HOC мы можем сделать данные с клиента доступными для компонентов, которые обернуты компонентом более высокого порядка! Хотя в настоящее время мы можем использовать graphql() HOC, есть некоторые недостатки его использования.

Когда компоненту требуется доступ к нескольким резолверам, для этого нужно **составить** несколько компонентов высшего порядка graphql(). Компоновка *(прим. перев. - composing)* нескольких HOC может затруднить понимание того, как данные передаются вашим компонентам. В некоторых случаях порядок HOC может иметь значение, что может легко привести к ошибкам при рефакторинге кода.

После выпуска Hooks компания Apollo добавила поддержку Hooks в библиотеку Apollo Client. Вместо того чтобы использовать компонент высшего порядка

graphql(), разработчики теперь могут напрямую обращаться к данным через hooks, которые предоставляет библиотека.

Давайте рассмотрим пример, в котором используются точно такие же данные, как и в примере с компонентом высшего порядка graphql(). На этот раз мы предоставим данные компоненту с помощью хука useMutation, который нам предоставил Apollo Client.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/apollo-hoc-hooks-n3td8>*

Используя хук useMutation, мы сократили объем кода, который был необходим для предоставления данных компоненту.

Помимо сокращения объема кода, стало намного проще использовать данные нескольких резолверов в одном компоненте. Вместо того чтобы создавать несколько компонентов более высокого порядка, мы можем просто написать несколько hooks в компоненте. Знать, как данные передаются в компонент, гораздо проще, и это улучшает опыт разработчиков при рефакторинге компонентов или разбиении их на более мелкие части.

**Плюсы**

Использование паттерна HOC позволяет нам хранить логику, которую мы хотим использовать повторно, в одном месте. Это снижает риск случайного распространения ошибок по всему приложению путем многократного дублирования кода, что может привести к появлению новых ошибок. Сохраняя логику в одном месте, мы можем придерживаться принципа DRY и легко обеспечивать **разделение задач.**

**Минусы**

Имя prop, который HOC может передать элементу, может вызвать коллизию именования.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.078.png)

В этом случае HOC withStyles добавляет свойство style к элементу, который мы ему передаем. Однако компонент Button уже имел свойство style, которое будет перезаписано! Убедитесь, что HOC может справиться со случайным столкновением имен, либо переименовав prop, либо объединив props.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.079.jpeg)

При использовании нескольких **составленных** HOC, которые передают props элементу, обернутому в них, может быть трудно определить, какой HOC отвечает за какой prop. Это может затруднить отладку и масштабирование приложения.

- **Паттерн «Render Props»**

*Передача элементов JSX компонентам через props*

В разделе о компонентах высшего порядка мы видели, что возможность повторного использования логики компонентов может быть очень удобной, если нескольким компонентам нужен доступ к одним и тем же данным или они содержат одну и ту же логику.

Еще один способ сделать компоненты очень многоразовыми — это использование паттерна render prop. render prop — это параметр компонента, значением которого является функция, возвращающая JSX-элемент. Сам компонент не выводит ничего, кроме render prop. Вместо этого компонент просто вызывает render prop, вместо того чтобы реализовывать свою собственную логику рендеринга.

Представьте, что у нас есть компонент Title. В этом случае компонент Title не должен делать ничего, кроме рендеринга переданного нам значения. Для этого мы можем использовать render prop! Давайте передадим значение, которое мы хотим, чтобы компонент Title отобразил, в render prop.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.080.png)

В компоненте Title мы можем отобразить эти данные, вернув вызванный render prop!

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.081.png)

Элементу Component мы должны передать свойство render, которое представляет собой функцию, возвращающую элемент React.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/renderprops2-y6wst>*

Отлично, работает гладко! Самое замечательное в render props то, что компонент, который получает props, очень многоразовый. Мы можем использовать его несколько раз, передавая каждый раз разные значения render props.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/young-silence-hou0c>*

Хотя они называются render props, render prop не обязательно должен называться render. Любой prop, который рендерит JSX, считается render prop! Давайте переименуем render props, которые использовались в предыдущем примере, и дадим им конкретные имена!

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/renderprops2-u0sfh>*

Отлично! Мы только что увидели, что можно использовать render props для того, чтобы сделать компонент многоразовым, поскольку мы можем каждый раз передавать в render prop разные данные. Но зачем вам это нужно?

Компонент, который принимает render prop, обычно делает гораздо больше, чем просто вызывает render prop. Вместо этого мы обычно хотим передать данные от компонента, который принимает render prop, к элементу, который мы передаем в качестве render prop!

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.082.png)

Теперь render prop может получить это значение, которое мы передали в качестве аргумента.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.083.png)

Давайте рассмотрим пример! У нас есть простое приложение, в котором пользователь может ввести температуру в градусах Цельсия. Приложение показывает значение этой температуры в градусах Фаренгейта и Кельвина.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/suspicious-hill-wk0uy>*

Хм... В настоящее время есть проблема. Компонент Input с состоянием содержит значение пользовательского ввода, что означает, что компоненты Fahrenheit и Kelvin не имеют доступа к пользовательскому вводу!

**Поднятие состояния**

Чтобы сделать пользовательский ввод доступным как для компонента по Фаренгейту, так и по Кельвину в приведенном выше примере, нам придется **поднять состояние.**

В данном случае у нас есть компонент Input с состоянием. Однако родственные компоненты Fahrenheit и Kelvin также нуждаются в доступе к этим данным. Вместо того чтобы иметь компонент Input с состоянием, мы можем поднять состояние до первого общего компонента-предка, который имеет связь с Input, Fahrenheit и Kelvin: в данном случае это компонент App!

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.084.jpeg)

Хотя это правильное решение, может быть сложно поднимать состояние в больших приложениях с компонентами, которые обрабатывают множество дочерних элементов. Каждое изменение состояния может вызвать повторный рендеринг всех дочерних компонентов, даже тех, которые не обрабатывают данные, что может негативно сказаться на производительности вашего приложения.

**Render props**

Вместо этого мы можем использовать render props! Давайте изменим компонент Input таким образом, чтобы он мог получать render props.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.085.jpeg)

Отлично, теперь компоненты Kelvin и Fahrenheit имеют доступ к value введенного пользователем значения!

**children как функция**

Помимо обычных JSX-компонентов, мы можем передавать функции в качестве дочерних компонентов компонентам React. Эта функция доступна нам через prop children, который технически также является render prop.

Давайте изменим компонент Input. Вместо того чтобы явно передавать render prop, мы просто передадим функцию в качестве child для компонента Input.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.086.jpeg)

У нас есть доступ к этой функции через prop props.children, доступный для компонента Input. Вместо вызова props.render со значением пользовательского ввода, мы вызовем props.children со значением пользовательского ввода.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.087.jpeg)

Отлично, таким образом компонент Kelvin и Fahrenheit получит доступ к value, не заботясь об имени render prop.

**Hooks**

В некоторых случаях мы можем заменить render props на хуки. Хорошим примером этого является [Apollo Client.](https://www.apollographql.com/docs/react)

Одним из способов использования Apollo Client являются компоненты Mutation и Query. Давайте рассмотрим тот же пример Input, который был рассмотрен в разделе «Компоненты высшего порядка». Вместо того чтобы использовать компонент высшего порядка graphql(), мы теперь воспользуемся компонентом Mutation, который получает render prop.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/confident-lederberg-jfdxg>*

Чтобы передать данные от компонента Mutation вниз к элементам, которым эти данные нужны, мы передаем функцию в качестве дочернего элемента. Функция получает значение данных через свои аргументы.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.088.png)

Хотя мы все еще можем использовать паттерн render prop, и он часто предпочтительнее паттерна HOC, у него есть свои недостатки.

Одним из таких недостатков является глубокая вложенность компонентов. Мы можем вложить несколько компонентов Mutation или Query, если компоненту нужен доступ к нескольким мутациям или запросам.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.089.jpeg)

После выхода хуков компания Apollo добавила поддержку хуков в библиотеку Apollo Client. Вместо того чтобы использовать render props Mutation и Query, разработчики теперь могут напрямую обращаться к данным через хуки, которые предоставляет библиотека.

Давайте рассмотрим пример, в котором используются точно такие же данные, как и в примере с render prop Query. На этот раз мы предоставим данные компоненту с помощью хука useQuery, который нам предоставил Apollo Client.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/apollo-hoc-hooks-n3td8>*

Используя хук useQuery, мы сократили объем кода, который был необходим для предоставления данных компоненту.

**Плюсы**

Обмен логикой и данными между несколькими компонентами легко осуществляется с помощью паттерна render props. Компоненты можно сделать очень многоразовыми, используя prop render или children. Хотя паттерн HOC в основном решает те же проблемы, а именно многократное использование и совместное использование данных, паттерн render props решает некоторые проблемы, с которыми мы можем столкнуться при использовании паттерна HOC.

Проблема столкновения имен, с которой мы можем столкнуться при использовании паттерна HOC, больше не встречается при использовании паттерна render props, поскольку мы не объединяем props автоматически. Мы явно передаем props дочерним компонентам, причем значение предоставляется родительским компонентом. Поскольку мы явно передаем props, мы решаем проблему **неявных props** HOC. Props, которые должны быть переданы вниз элементу, все видны в списке аргументов render prop. Таким образом, мы точно знаем, откуда берутся определенные props.

С помощью render props мы можем отделить логику нашего приложения от компонентов рендеринга. Компонент с состоянием, получивший render props, может передать данные компонентам без состояния, которые просто отображают данные. **Минусы**

Проблемы, которые мы пытались решить с помощью render props, в значительной степени были заменены React Hooks. Поскольку хуки изменили способ добавления возможности повторного использования и обмена данными с компонентами, они могут заменить паттерн render props во многих случаях.

Поскольку мы не можем добавить методы жизненного цикла в render prop, мы можем использовать его только для компонентов, которым не нужно изменять получаемые данные.

- **Паттерн Hooks («Хуки»)**

*Возможность использования функции для повторного использования логики с учетом состояния между несколькими компонентами в приложении*

В React 16.8 появилась новая функция под названием [хуки](https://reactjs.org/docs/hooks-intro.html). Хуки позволяют использовать состояние React и методы жизненного цикла без необходимости использовать компонент класса ES2015.

Хотя хуки не обязательно являются паттерном проектирования, они играют очень важную роль в дизайне вашего приложения. Многие традиционные паттерны проектирования могут быть заменены на хуки.

**Классовые компоненты**

До появления хуков в React нам приходилось использовать компоненты классов, чтобы добавлять в компоненты методы состояния и жизненного цикла. Типичный компонент класса в React может выглядеть примерно так:

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.090.jpeg)

Компонент класса может содержать состояние в своем конструкторе, методы жизненного цикла, такие как componentDidMount и componentWillUnmount для выполнения побочных эффектов, основанных на жизненном цикле компонента, и пользовательские методы для добавления дополнительной логики в класс.

Хотя мы по-прежнему можем использовать компоненты классов после внедрения React Hooks, использование компонентов классов может иметь некоторые недостатки! Давайте рассмотрим некоторые из наиболее распространенных проблем при использовании компонентов классов.

**Понимание классов ES2015**

Поскольку компоненты класса были единственным компонентом, который мог обрабатывать состояние и методы жизненного цикла до появления React Hooks, мы часто сталкивались с необходимостью рефакторинга функциональных компонентов в компоненты класса, чтобы добавить дополнительную функциональность.

В этом примере у нас есть простой div, который работает как кнопка.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.091.png)

Вместо того чтобы всегда отображать состояние «disabled», мы хотим менять его на «enabled», когда пользователь нажимает на кнопку, и добавлять некоторые дополнительные CSS-стили для кнопки, когда это происходит.

Для этого нам нужно добавить состояние в компонент, чтобы знать, включен статус или отключен. Это означает, что нам придется полностью переработать функциональный компонент и сделать его компонентом класса, который будет отслеживать состояние кнопки.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.092.jpeg)

Наконец, наша кнопка работает так, как мы хотим! *С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/throbbing-currying-2lp9w>*

В этом примере компонент очень маленький, и рефакторинг не представлял особой сложности. Однако в реальной жизни ваши компоненты, вероятно, содержат гораздо больше строк кода, что делает рефакторинг компонента гораздо более сложным. Помимо того, что вам нужно убедиться, что вы случайно не измените какое-либо поведение при рефакторинге компонента, вам также необходимо понять, как работают классы ES2015. Почему мы должны привязывать пользовательские методы? Что делает конструктор? Откуда взялось ключевое слово this? Бывает трудно понять, как правильно рефакторить компонент, случайно не изменив поток данных.

**Реструктуризация**

Общим способом разделения кода между несколькими компонентами является использование паттерна компонента высшего порядка или паттерна Render Props. Хотя оба паттерна являются правильными и являются хорошей практикой, добавление этих паттернов в более поздний период времени требует реструктуризации вашего приложения.

Помимо необходимости перестройки приложения, которая тем сложнее, чем больше у вас компонентов, наличие большого количества компонентов-оберток для обмена кодом между более глубоко вложенными компонентами может привести к тому, что лучше всего называется как - адом оберток. Нередко можно открыть инструменты разработчика и увидеть структуру, похожую на:

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.093.jpeg)

Ад оберток может затруднить понимание того, как данные проходят через ваше приложение, что может затруднить выявление причин неожиданного поведения.

**Сложность**

По мере добавления большего количества логики в компоненты классов размер компонента быстро увеличивается. Логика внутри этого компонента может стать запутанной и неструктурированной, что может затруднить разработчикам понимание того, где в компоненте класса используется определенная логика. Это может затруднить отладку и оптимизацию производительности.

Методы жизненного цикла также требуют довольно много дублирования в коде. Давайте рассмотрим пример, в котором используются компонент Counter и компонент Width.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/bold-brown-bzhpw>*

Структуру компонента App можно представить следующим образом:

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.094.jpeg)Хотя это небольшой компонент, логика внутри него уже довольно запутанная. В то время как некоторые части специфичны для логики счетчика, другие части специфичны для логики ширины. По мере роста компонента может становиться все труднее структурировать логику внутри компонента, находить связанную логику внутри компонента.

Помимо запутанной логики, мы также **дублируем** некоторую логику в методах жизненного цикла. Как в componentDidMount, так и в componentWillUnmount мы настраиваем поведение приложения на основе события изменения размера окна.

**Hooks**

Совершенно очевидно, что компоненты классов не всегда являются отличной вариантом использования в React. Чтобы решить распространенные проблемы, с которыми могут столкнуться разработчики React при использовании компонентов классов, в React появились React Hooks. React Hooks — это функции, которые можно использовать для управления состоянием компонентов и методами жизненного цикла. React Hooks позволяют:

- добавлять состояние в функциональный компонент;
- управлять жизненным циклом компонента без необходимости использования методов жизненного цикла, таких как componentDidMount и componentWillUnmount;
- повторно использовать одну и ту же логику работы с состоянием в нескольких компонентах приложения.

Сначала рассмотрим, как можно добавить состояние в функциональный компонент, используя React Hooks.

**Хук состояния**

React предоставляет хук, который управляет состоянием внутри функционального компонента, называемый useState.

Давайте посмотрим, как компонент класса может быть реструктурирован в функциональный компонент с помощью хука useState. У нас есть компонент

класса под названием Input, который просто отображает поле ввода. Значение input в состоянии обновляется всякий раз, когда пользователь вводит что-либо в поле ввода.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.095.jpeg)Чтобы использовать хук useState, нам нужно получить доступ к методу useState, который предоставляет нам React. Метод useState ожидает аргумент: это начальное значение состояния, в данном случае пустая строка.

Мы можем деструктурировать два значения из метода useState:

1. **Текущее значение** состояния.
1. **Метод, с помощью которого мы можем обновить** состояние.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.096.png)

Первое значение можно сравнить с параметром this.state.[value] компонента класса. Второе значение можно сравнить с методом this.setState компонента класса. Поскольку мы имеем дело с input value *(прим. перев. - значением input’а)*, назовем текущее значение состояния input, а метод для обновления состояния setInput. Начальным значением должна быть пустая строка.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.097.png)

Теперь мы можем рефакторить компонент класса Input в функциональный компонент с состоянием.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.098.png)

Значение поля ввода равно текущему значению состояния ввода, как и в примере с компонентом класса. Когда пользователь набирает текст в поле ввода, значение состояния ввода обновляется соответствующим образом с помощью метода setInput. *С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/nervous-hoover-oicu6>*

**Хук эффекта**

Мы видели, что можно использовать компонент useState для обработки состояния в функциональном компоненте, но еще одним преимуществом компонентов класса была возможность добавить методы жизненного цикла в компонент.

С помощью хука useEffect мы можем *«подключиться»* к жизненному циклу компонента. Хук useEffect эффективно объединяет методы жизненного цикла componentDidMount, componentDidUpdate и componentWillUnmount.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.099.png)

Давайте воспользуемся примером ввода, который мы использовали в разделе Хук состояния. Каждый раз, когда пользователь вводит что-либо в поле ввода, мы также хотим записывать это значение в консоль.

Нам нужно использовать хук useEffect, который «слушает» значение ввода. Мы можем сделать это, добавив input в **массив зависимостей** хука useEffect. Массив зависимостей — это второй аргумент, который получает хук useEffect.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.100.png)

Давайте попробуем!

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/blissful-ramanujan-p237n>*

Значение ввода теперь записывается в консоль каждый раз, когда пользователь набирает значение.

**Пользовательские хуки**

Помимо встроенных хуков, которые предоставляет React (useState, useEffect, useReducer, useRef, useContext, useMemo, useImperativeHandle, useLayoutEffect, useDebugValue, useCallback), мы можем легко создавать свои собственные хуки.

Вы могли заметить, что все хуки начинаются с use. Важно начинать ваши хуки с use, чтобы React проверял, не нарушает ли он правила хуков.

Допустим, мы хотим отслеживать определенные клавиши, которые пользователь может нажать при вводе. Наш пользовательский хук должен иметь возможность получать в качестве аргумента клавишу, которую мы хотим отслеживать.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.101.png)

Мы хотим добавить слушатель событий keydown и keyup для клавиши, которую пользователь передал в качестве аргумента. Если пользователь нажал эту кнопку, то есть сработало событие keydown, состояние внутри хука должно переключиться на true. В противном случае, когда пользователь перестанет нажимать на эту кнопку, сработает событие keyup, и состояние переключится на false.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.102.jpeg)

Отлично! Мы можем использовать этот пользовательский хук в нашем приложении ввода. Давайте выводить журнал в консоль каждый раз, когда пользователь нажимает клавишу q, l или w.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/billowing-pine-xplez>*

Вместо того чтобы хранить логику нажатия клавиш локально в компоненте Input, теперь мы можем повторно использовать хук useKeyPress в нескольких компонентах, без необходимости переписывать одну и ту же логику снова и снова.

Еще одним большим преимуществом хуков является то, что сообщество может создавать хуки и делиться ими. Мы только что сами написали хук useKeyPress, но на самом деле в этом не было никакой необходимости! Хук уже был создан кем-то *(прим. перев. - https://github.com/streamich/react-use/blob/master/docs/useKeyPress.md)* другим и готов к использованию в нашем приложении, стоило нам только установить его!

Вот несколько сайтов, на которых перечислены все хуки, созданные сообществом и готовые к использованию в вашем приложении.

- React Use (https://github.com/streamich/react-use)
- useHooks (https://usehooks.com/)
- Collection of React Hooks (https://nikgraf.github.io/react-hooks/)

Давайте перепишем пример со счетчиком и шириной, показанный в предыдущем разделе. Вместо использования компонента класса мы перепишем приложение с помощью React Hooks.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/eloquent-bhabha-2w0ll>*

Мы разбили логику функции App на несколько частей:

- useCounter: Пользовательский хук, который возвращает текущее значение count, метод инкремента и метод декремента.
- useWindowWidth: пользовательский хук, который возвращает текущую ширину окна.
- App: Функциональный компонент с состоянием, который возвращает значение счетчика и ширины.

Используя React Hooks вместо компонента класса, мы смогли разбить логику на более мелкие, многократно используемые части, разделяющие логику.

Давайте визуализируем изменения, которые мы только что сделали, по сравнению со старым компонентом класса App.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.103.jpeg)

Использование React Hooks просто позволило **разделить логику** нашего компонента на несколько небольших частей. Повторное использование одной и той же stateful логики стало намного проще, и нам больше не нужно переписывать функциональные компоненты в компоненты классов, если мы хотим сделать компонент stateful. Хорошее знание классов ES2015 больше не требуется, а наличие многократно используемой stateful логики повышает тестируемость, гибкость и читабельность компонентов.

**Руководство по дополнительным хукам**

Как и в других компонентах, существуют специальные функции, которые используются, когда вы хотите добавить хуки в написанный вами код. Вот краткий обзор некоторых распространенных хук-функций:

1. **useState** Хук useState позволяет разработчикам обновлять состояние и манипулировать им внутри функциональных компонентов без необходимости преобразовывать его в компонент класса. Одним из преимуществ этого хука является то, что он прост и не требует такой сложности, как другие хуки React.
1. **useEffect** Хук useEffect используется для запуска кода во время основных событий жизненного цикла функционального компонента. В основном теле функционального компонента не допускаются мутации, подписки, таймеры, логирование и другие побочные эффекты. Если их разрешить, это может привести к запутанным ошибкам и несоответствиям в пользовательском интерфейсе. Хук useEffect предотвращает все эти «побочные эффекты» и позволяет пользовательскому интерфейсу работать плавно. Это комбинация компонентов componentDidMount, componentDidUpdate и componentWillUnmount, собранных в одном месте.
1. **useContext** Хук useContext принимает объект контекста, который является значением, возвращаемым из React.createcontext, и возвращает текущее значение контекста для этого контекста. Хук useContext также работает с React Context API, чтобы обмениваться данными в приложении без необходимости передавать props приложения вниз через различные уровни. Следует отметить, что аргументом, передаваемым хуку useContext, должен быть сам объект контекста, и любой компонент, вызывающий useContext, всегда выполняет повторный рендеринг при изменении значения контекста.
1. **useReducer** Хук useReducer дает альтернативу setState и особенно предпочтителен, когда у вас сложная логика состояния, включающая несколько подзначений, или когда следующее состояние зависит от предыдущего. Он принимает на вход функцию reducer и начальное состояние и возвращает на выходе текущее состояние и функцию диспетчеризации с помощью деструктуризации массива. useReducer также оптимизирует производительность компонентов, которые вызывают глубокие обновления.

**Плюсы и минусы использования хуков**

Вот некоторые преимущества использования хуков:

**Меньше строк кода**

Хуки позволяют группировать код по задачам и функциональности, а не по жизненному циклу. Это делает код не только чище и лаконичнее, но и короче. Ниже приведено сравнение простого компонента без статических данных — таблицы данных о продукте с возможностью поиска с помощью React и того, как он выглядит с хуками после использования ключевого слова useState.

**Компоненты без состояния**

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.104.jpeg)

**Тот же компонент с хуками**

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.105.jpeg)

**Упрощает сложные компоненты**

Классы JavaScript могут быть сложны в управлении, их трудно использовать при обновлении *(прим. перев. - hot reloading)* и они могут не минифицироваться. React Hooks решает эти проблемы и обеспечивает простоту функционального программирования. С внедрением хуков нам не нужны компоненты классов. **Повторное использование логики с использованием состояния**

Классы в JavaScript поощряют многоуровневое наследование, которое быстро увеличивает общую сложность и вероятность ошибок. Однако хуки позволяют использовать состояние и другие возможности React без написания класса. В React вы всегда можете повторно использовать логику с состоянием без необходимости переписывать код снова и снова. Это снижает вероятность ошибок и позволяет создавать композиции с обычными функциями.

**Совместное использование невизуальной логики**

До внедрения хуков у React не было способа извлечения и обмена невизуальной логикой. В итоге это привело к появлению более сложных элементов, таких как паттерны HOC и Render props, только для того, чтобы решить общую проблему. Но введение хуков решило эту проблему, поскольку позволяет извлекать логику с состоянием в простую функцию JavaScript.

Конечно, у хуков есть некоторые потенциальные недостатки, о которых стоит помнить:

- Приходится соблюдать его правила, без плагина linter трудно понять, какое правило было нарушено.
- Требуется значительное время на тренировку для правильного использования (Exp: useEffect).
- Будьте осведомлены о неправильном использовании (Exp: useCallback, useMemo).

**React хуки против классов**

Когда в React появились хуки, это создало новую проблему: как узнать, когда использовать функциональные компоненты с хуками и компоненты классов? С помощью хуков можно получить состояние и частичный жизненный цикл хуков даже в функциональных компонентах. Хуки также позволяют использовать локальное состояние и другие возможности React без написания класса.

Вот некоторые различия между хуками и классами, которые помогут вам принять решение:

**React Hooks**

- помогает избежать множественных иерархий и сделать код более понятным
- обеспечивает единообразие для всех компонентов React

**Классы**

- Обычно, когда вы используете HOC или renderProps, вам приходится реструктурировать ваше приложение с множественными иерархиями, когда вы пытаетесь увидеть его в DevTools.
- Классы запутывают как людей, так и машины из-за необходимости понимать привязку и контекст, в котором вызываются функции.
- **Паттерн «Flyweight»**

*Повторное использование существующих экземпляров при работе с идентичными объектами*

Паттерн flyweight — это полезный способ экономии памяти при создании большого количества одинаковых объектов.

В нашем приложении мы хотим, чтобы пользователи могли добавлять книги. Все книги имеют название, автора и номер isbn! Однако в библиотеке обычно нет только одного экземпляра книги: там обычно есть несколько экземпляров одной и той же книги. Было бы не очень удобно каждый раз создавать новый экземпляр книги, если есть несколько экземпляров одной и той же книги. Вместо этого мы хотим создать несколько экземпляров конструктора Book, которые представляют одну книгу.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.106.png)

Давайте создадим функциональность для добавления новых книг в список. Если книга имеет тот же номер ISBN и, следовательно, точно такой же тип книги, мы не хотим создавать совершенно новый экземпляр Book. Вместо этого мы должны сначала проверить, существует ли уже такая книга.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.107.png)

Если он еще не содержит номер ISBN книги, мы создадим новую книгу и добавим ее номер ISBN в набор isbnNumbers.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.108.jpeg)

Функция createBook помогает нам создавать новые экземпляры книг одного типа. Однако в библиотеке обычно содержится несколько экземпляров одной и той же книги! Давайте создадим функцию addBook, которая позволит нам добавить несколько экземпляров одной и той же книги. Она должна вызывать функцию createBook, которая возвращает либо вновь созданный экземпляр Book, либо возвращает уже существующий экземпляр.

Чтобы отслеживать общее количество копий, создадим массив bookList, который будет содержать общее количество книг в библиотеке.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.109.jpeg)

Отлично! Вместо того чтобы создавать новый экземпляр книги каждый раз, когда мы добавляем копию, мы можем эффективно использовать уже существующий экземпляр книги для этой конкретной копии. Давайте создадим 5 копий трех книг: «Гарри Поттер», «Убить пересмешника» и «Великий Гэтсби».

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.110.png)

Хотя существует 5 экземпляров, у нас есть только 3 экземпляра книги! *С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/wandering-firefly-m5c31>*

Паттерн flyweight полезен при создании огромного количества объектов, которые потенциально могут поглотить всю доступную **оперативную память**. Он позволяет минимизировать объем потребляемой памяти.

В JavaScript мы можем легко решить эту проблему с помощью прототипного наследования. В настоящее время аппаратное обеспечение имеет гигабайты оперативной памяти, что делает паттерн flyweight менее важным.

- **Паттерн «Фабрика»**

*Используйте функцию фабрики для создания объектов*

С помощью паттерна фабрики мы можем использовать **фабричные функции** для создания новых объектов. Функция является фабричной, если она возвращает новый объект без использования ключевого слова new!

Допустим, нам нужно много пользователей для нашего приложения. Мы можем создать новых пользователей со свойствами firstName, lastName и email. Функция factory добавляет свойство fullName к вновь созданному объекту, которое возвращает firstName и lastName.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.111.png)

Отлично! Теперь мы можем легко создавать несколько пользователей, вызывая функцию createUser.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/divine-glade-8s5cv>*

Паттерн фабрика может быть полезен, если мы создаем относительно сложные и конфигурируемые объекты. Может случиться так, что значения ключей и значений зависят от определенной среды или конфигурации. С помощью этого паттерна мы можем легко создавать новые объекты, содержащие пользовательские ключи и значения!

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.112.png)

**Плюсы**

Паттерн фабрика полезен, когда нам нужно создать несколько небольших объектов с одинаковыми свойствами. Функция фабрики может легко вернуть пользовательский объект в зависимости от текущей среды или пользовательской конфигурации. **Минусы**

В JavaScript паттерн фабрики — это не более чем функция, которая возвращает объект без использования ключевого слова new. Стрелочные функции ES6 позволяют нам создавать небольшие фабричные функции, которые **неявно возвращают** объект каждый раз.

Однако во многих случаях может оказаться более эффективным с точки зрения экономии памяти создавать каждый раз новые экземпляры вместо новых объектов.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.113.jpeg)

- **Паттерн «Compound»**

*Создание нескольких компонентов, которые работают вместе для выполнения одной задачи*

В нашем приложении часто есть компоненты, которые принадлежат друг другу. Они зависят друг от друга через общее состояние и совместно используют логику. Это часто встречается в таких компонентах, как select, выпадающие компоненты или пункты меню. Паттерн составного компонента *(прим. перев. - Compound)* позволяет создавать компоненты, которые работают вместе для выполнения определенной задачи.

**Context API**

Рассмотрим пример: у нас есть список изображений белок! Помимо простого показа изображений белок, мы хотим добавить кнопку, позволяющую пользователю редактировать или удалять изображения. Мы можем реализовать компонент FlyOut, который показывает список, когда пользователь переключает компонент.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/s/provider-pattern-2-ck29r?from-embed>*

В компоненте FlyOut, по сути, есть три элемента:

- Обертка FlyOut, которая содержит кнопку переключения и список.
- Кнопка переключения *(прим. перев. - Toggle),* которая переключает список.
- Список *(прим. перев. - List)*, который содержит список пунктов меню.

Использование паттерна составного компонента с [Context API](https://reactjs.org/docs/context.html) React идеально подходит для этого примера!

Сначала создадим компонент FlyOut. Этот компонент сохраняет **состояние** и возвращает FlyOutProvider со значением переключения всем полученным **дочерним** элементам.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.114.jpeg)

Теперь у нас есть компонент FlyOut с состоянием, который может передавать значение open и toggle своим дочерним элементам!

Давайте создадим компонент Toggle. Этот компонент просто отображает компонент, на котором пользователь может щелкнуть, чтобы переключить меню.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.115.png)

Для того чтобы предоставить Toggle доступ к FlyOutContext Provider, нам нужно отобразить его как дочерний компонент FlyOut! Мы можем просто отобразить его как дочерний компонент. Однако мы также можем сделать компонент Toggle свойством компонента FlyOut!

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.116.jpeg)

Это означает, что если мы захотим использовать компонент FlyOut в каком-либо файле, нам нужно будет только импортировать FlyOut!

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.117.png)

Простого переключения недостаточно. Нам также необходимо иметь список с элементами списка, которые открываются и закрываются в зависимости от значения open.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.118.png)

Компонент List отображает свои дочерние элементы в зависимости от того, является ли значение open истинным или ложным. Давайте сделаем List и Item свойством компонента FlyOut, как мы это сделали с компонентом Toggle.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.119.jpeg)Теперь мы можем использовать их в качестве свойств компонента FlyOut! В данном случае мы хотим показать пользователю две опции: **Редактировать** и **Удалить.** Давайте создадим FlyOut.List, который отобразит два компонента FlyOut.Item, один для опции **Edit,** а другой для опции **Delete.**

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.120.jpeg)

Отлично! Мы только что создали целый компонент FlyOut без добавления состояния в само меню FlyOutMenu!

Паттерн Comound отлично подходит для создания библиотеки компонентов. Вы часто увидите этот паттерн при использовании библиотек пользовательского интерфейса, таких как Semantic UI.

[**React.Children.map**](https://reactjs.org/docs/react-api.html#reactchildrenmap)

Мы также можем реализовать паттерн Compound Component, отображая дочерние элементы компонента. Мы можем добавить свойства open и toggle к этим элементам, [**клонируя**](https://reactjs.org/docs/react-api.html#cloneelement) их с помощью дополнительных props.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.121.png)

Все дочерние компоненты клонируются, и им передаются значения open и toggle. Вместо того чтобы использовать Context API, как в предыдущем примере, мы теперь имеем доступ к этим двум значениям через props.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/provider-pattern-2-j9l1k>*

**Плюсы**

Compound компоненты управляют своим собственным внутренним состоянием, которое они делят между несколькими дочерними компонентами. При реализации compound компонента нам не нужно беспокоиться об управлении состоянием самостоятельно.

При импорте compound компонента нам не нужно явно импортировать дочерние компоненты, доступные для этого компонента.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.122.jpeg)

**Минусы**

При использовании React.Children.map для предоставления значений вложенность компонентов ограничена. Доступ к props open и toggle будут иметь только прямые дочерние компоненты родительского компонента, что означает, что мы не можем обернуть любой из этих компонентов в другой компонент.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.123.jpeg)

Клонирование элемента с помощью React.cloneElement выполняет **неглубокое слияние.** Уже существующие props будут объединены с новыми props, которые мы передаем. Это может привести к **столкновению имен,** если уже существующий prop имеет то же имя, что и prop, который мы передаем в метод React.cloneElement. Поскольку props объединяются неглубоко, значение этого prop будет перезаписано последним значением, которое мы передаем.

- **Паттерн Command («Командный»)**

*Возможность отделить методы, которые выполняют задачи, посылая команды командиру*

С помощью данного паттерна мы можем отделить объекты, выполняющие определенную задачу, от объекта, вызывающего метод.

Допустим, у нас есть онлайн-платформа доставки еды. Пользователи могут размещать, отслеживать и отменять заказы.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.124.jpeg)

В классе OrderManager у нас есть доступ к методам placeOrder, trackOrder и cancelOrder. Было бы совершенно правильным JavaScript просто использовать эти методы напрямую!

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.125.png)

Однако, у вызова методов непосредственно на экземпляре manager есть свои недостатки. Может случиться так, что впоследствии мы решим переименовать некоторые методы, или функциональность методов изменится.

Скажем, вместо того чтобы называть метод placeOrder, мы теперь переименуем его в addOrder! Это означает, что нам придется убедиться в том, что мы не вызываем метод placeOrder нигде в нашей кодовой базе, что может оказаться очень сложным в больших приложениях.

Вместо этого мы хотим отделить методы от объекта manager и создать отдельные командные функции для каждой команды!

Давайте отрефакторим класс OrderManager: вместо методов placeOrder, cancelOrder и trackOrder у него будет один единственный метод: execute. Этот метод будет выполнять любую переданную ему команду.

Каждая команда должна иметь доступ к заказам менеджера, которые мы передадим в качестве первого аргумента.

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.126.png)

Нам нужно создать три команды для заказов manager:

- PlaceOrderCommand
- CancelOrderCommand
- TrackOrderCommand

![](Aspose.Words.f8328127-283a-439d-bac4-ea2ee8abe571.127.jpeg)Отлично! Вместо того чтобы методы были напрямую связаны с экземпляром OrderManager, теперь они представляют собой отдельные, развязанные функции, которые мы можем вызвать через метод execute, доступный для OrderManager.

*С примером кода можно ознакомиться по ссылке: <https://codesandbox.io/embed/serene-sea-41ixg>*

**Плюсы**

Данные паттерн позволяет нам отделить методы от объекта, выполняющего операцию. Это дает вам больше контроля, если вы имеете дело с командами, которые имеют определенное время жизни, или командами, которые должны быть поставлены в очередь и выполняться в определенное время.

**Минусы**

Варианты использования данного паттерна весьма ограничены и часто добавляют в приложение ненужный boilerplate.
